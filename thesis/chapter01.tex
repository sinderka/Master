%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Skrive litt om problemet, layouten og slikt. \\
!!!!!!!!!!!!!!!!!!!!!!cite rapport og SLM !!!!!!!!!!!!!!!\\
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Cite hamiltonian!!!!!!!!!!!!!!!!!!!!\\
!!!!!!!!!!!!!!Dette kapitelet mangler en del struktur, datating og implementasjonsting!!!!!!!!!!!!!!!!!!\\
!!!!!!!!!!!!!!!mangler også testfunksjoner!!!!!!!!!!!!!!!!!!!!\\
!!!!!!!!!!!!!!!!!!!!!bedre layour!!!!!!!!!!!!!!!!!!!!!!!!\\
!!!!!!!!!!!!!!!!!!!!!Husk å endre KPM til arnoldi, og la PM være betegnelsen på metoden?!!!!!!!!!!!!!!!!!!!!\\
!!!!!!!!!!!!!!!!!!!!!!!!!labelene er definert mange ganger!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\
{\color{red} dkjafkjafajio } \\
{\color{red} PÅSKEEGG: } $\neptune$ \\
The equation 
\begin{equation} 
\begin{aligned}
\dot{u}(t) &= A u(t) + F(t) = g(t) \\
u(0)&= u_0
\end{aligned}
\label{eqn:PDE}
\end{equation}
often makes an appearance when solving partial differential equations with numerical methods. The author has earlier observed how the heat equation, discretized with finite difference methods to be on the form of equation \eqref{eqn:PDE} can be solved with the use of the Krylov projection method(KPM) \cite{min}. This note will continue on the same track, with more focus on the wave equation, and energy preservation. It will also feature a comparison between symplectic Lanzcos method(SLM) \cite{SLM} and KPM. SLM is a projection technique that only works on Hamiltonian matrices. Due to this, SLM (claim to) preserve energy better than KPM. This note will also compare time consumption and error for the different methods, but not much theoretical derivation. For this I recommend reading \cite{elena}, \cite{min}, and \cite{luli}. \\

!!!!!!!!!!!!!!!!!!!MÅ cite forsjkellig når jeg vil/anbefaler å lese hele, og når jeg anbefaler å lese deler av det?!!!!!!!!!\\
%!!!!!!!!!!!!!!!!!!!Må cite den jeg fikk av LuLi!!!!!!!!!!!!!!!!!!!!!!!!\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Explonation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!!!!!!!!!!!!!!!!!Alt må leses igjennom!!!!!!!!!!!!!!!!\\
!!!!!!!!!!!!!!!!!!!Citinger må fikses!!!!!!!!!!!!!!!!!!!\\
!!!!!!!!!!!!!!!!!!Bilder må oppdateres!!!!!!!!!!!!!!!!!!!!!!!\\
!!!!!!!!!!!!!!!!!!!!!!Det må skrives en del tekts mange steder!!!!!!!!!!!!!!!!!\\
!!!!!!!!!!!!!!!!!!og bedre forklaringer mange steder!!!!!!!!!!!!!!!!!!!!!!!\\
!!!!!!!!!!!!!!!!!!mye å ta tak i med andre ord!!!!!!!!!!!!!!!!\\
!!!!!!!!!!!!!!!!!!!KPM er ikke det samme som SLM?!!!!!!!!!!!!!!!!!!\\
!!!!!!!!!!!!!!!!!!!Størrelse på $J$?!!!!!!!!!!!!!!!!!!!!!!!!
There will here be a short explanation of all solvers, constants, out data and expressions used in this text. MATLAB notation is used where applicable.% Fell free to go straight to next chapter, and use this as a reference later in the note.

\section{Projection methods}
As mentioned earlier, two projection methods will be presented, KPM and SLM. They are very similar in nature, with the only difference being the orthogonalisation method. KPM uses Arnoldi's algorithm, given in Algorithm \ref{alg:arnoldi}, and SLM uses the symplectic Lanczos method, given in Algorithm \ref{alg:symlanz}. The framework for both methods is given in Algorithm \ref{alg:PM}. \\

%!!!!!!!!!!!!!!!!!!Forklare forskjellen mellom $\tilde{m}$, $\hat{m}$ og $m$, samme med $n$!!!!!!!!!!!!!!!
%!!!!!!!!!!!!!!!!!Må forklare mer hva som er foskejllen på $m$ og $2m$!!!!!!!!!!!!!!!!!!!!\\
%!!!!!!!!!!!!!!!!!!!!forklare bedre hva $n$ er, og slikt!!!!!!!!!!!!!!!!!!!!!\\
\begin{algorithm} 
\begin{algorithmic} \caption{Arnoldi's algorithm\cite{arnold}} \label{alg:arnoldi}  
\STATE Start with $A \in \mathbb{R}^{\hat{m} \times \hat{m}}$, $v \in \mathbb{R}^{\hat{m}}$, $n \in \mathbb{N}$ and $\epsilon \in \mathbb{R}$.
\STATE $v_1 = v/\|v \|_2$
\FOR{$j = 1,2,\cdots, n $} 
   \STATE Compute $h_{i,j} =  v_iAv_j,v_i $ for $i = 1,2,\cdots, j$
    \STATE Compute $w_j = A v_j - \Sigma_{i=1}^{j} h_{i,j}v_i $
    \STATE $h_{j+1,j} = \| w_j \|_2$
    \IF{$h_{j+1,j} < \epsilon $} 
        \STATE\textbf{STOP}
    \ENDIF 
   \STATE $v_{j+1} = w_j/h_{j+1,j}$
\ENDFOR
\STATE Return $H$, $V$, $v_{n+1}$, $h_{n+1,n}$.
\end{algorithmic} 
\end{algorithm}

\begin{algorithm} \caption{Symplectic Lanczos method \cite{SLM}, with reortogonalization from \cite{SLMO}. } \label{alg:symlanz}
\begin{algorithmic}
\STATE Start with a Hamiltonian matrix $A \in \mathbb{R}^{2\tilde{m} \times 2 \tilde{m}}$, $\tilde{v_1} \in \mathbb{R}^{2 \tilde{m}}$, $\tilde{n} \in \mathbb{N}$
\STATE $v_0= 0 \in \mathbb{R}^{2 \tilde{m}}$
\STATE $\xi_1 = \| \tilde{v}_1\|_2$
\STATE $v_1= \frac{1}{\xi_1}  \tilde{v}_1$
\FOR {$j = 1,2, \cdots, \tilde{n}$}
	\STATE $v = A v_j$
	\STATE $\delta_j =  v_j^\top$
	\STATE $\tilde{w} = v-\delta_j v_j$
	\STATE $\kappa_j = v_j^\top J_{\tilde{m}} v $
	\STATE $w_j = \frac{1}{\kappa_j} \tilde{w_j}$
	\STATE $w = A w^j$
	\STATE $ \tilde{V}_{j-1} = [v_1,v_2,\cdots,v_{j-1},w_1,w_2,\cdots,w_{j-1}] $
	\STATE $ w_j = w_j + \tilde{V}_{j-1}J_{j-1} \tilde{V}_{j-1}^\top J_{\tilde{m}} w_j $
	\STATE $\beta = -w_j^\top J_{\tilde{m}} w$
	\STATE $\tilde{v}_{j+1} = w - \xi_j v_{j-1} - \beta_j v_j + \delta_j v_j$
	\STATE $ \xi_{j+1} = \|\tilde{v}_{j+1} \|_2 $
	\STATE $ v_{j+1} = \frac{1}{\xi_{j+1}} \tilde{v}_{j+1} $
	\STATE $ \tilde{V}_j = [v_1,v_2,\cdots,v_{j},w_1,w_2,\cdots,w_{j}] $
	\STATE $ v_{j+1} = v_{j+1} + \tilde{V}_j J_j \tilde{V}_j^\top J_{\tilde{m}} v_{j+1} $
\ENDFOR
\STATE $V = [v_1,v_2,\cdots,v_{\tilde{n}},w_1,w_2,\cdots,w_{\tilde{n}}]$
\STATE $H = \begin{bmatrix}
\text{diag} \big( [\delta_j]^n_{j=1} \big) & \text{tridiag}\big( [\xi_j]_{j=2}^n,[\beta_j]_{j=1}^n,[\xi_j]_{j=2}^n \big) \\
\text{diag} \big( [\kappa_j]^n_{j=1} \big) & \text{diag} \big( [-\delta_j]^n_{j=1} \big)
\end{bmatrix} $
\STATE Return $H$, $V$, $v_{n+1}$, $\xi_{n+1}$.
\end{algorithmic}
\end{algorithm}
% $\tilde{n}$ and $\tilde{m}$ given to Algorithm \ref{alg:symlanz} is half the size of $n$ and $\hat{m}$ given to Algorithm \ref{alg:arnoldi}, due to the way the orthogonalisation is done. This means that if you give the same Hamiltonian matrix to both algorithms, the $n$ you give SLM needs to be half the size of the $n$ you gives KPM. More concise
Note that the relation between $\hat{m}$, $\tilde{n}$, $\tilde{m}$ used it the algorithms is given by $\hat{m} = 2\tilde{m}= 2(m-2)^2$ and $ n = 2\tilde{n}$.

\begin{algorithm}[h]
\begin{algorithmic} \caption{Framework for the orthogonalisation methods\cite{min}} \label{alg:PM} 
\STATE Start with $A \in \mathbb{R}^{\hat{m} \times \hat{m}}$, $f(t)$, $v \in \mathbb{R}^{\hat{m}}$, $n \in \mathbb{N}$, a boolean value \texttt{restart}, an algorithm \texttt{alg}, $\epsilon \in \mathbb{R}$, and $i = 0$.
\STATE Compute $[V_n,H_n,h_{n+1,n}^i,v_{n+1}] = \texttt{alg}(A,v,n)$
\STATE Solve $  z_i'(t) = H_n z_i(t) + f(t) \| v \|_2 e_1  $ for $z_i(t)$
\STATE $ u_n(t) \leftarrow  V_n z_i(t) $
\STATE $ \delta = h_{n+1,n} $ 
\IF { \texttt{restart} == 1 }
	\WHILE{ $\epsilon < \delta$  } 
    		\STATE $i \leftarrow i + 1$
    		\STATE Compute $[V_n,H_n,h_{n+1,n}^i,v_{n+1}] = \texttt{alg}(A,v_{n+1},n)$
    		\STATE Solve $ z_i'(t) = H_n z_i(t) + h_{n+1,n}^{i-1}e_n^\top z_{i-1}(t)  $ for $z_i(t)$
    		\STATE $ u_n(t) \leftarrow u_n(t) + V_n z_i(t) $
    		\STATE $\delta = \max(u_n(t) - V_n z_i(t))$
	\ENDWHILE
\ENDIF
\STATE Return $u_n$.
\end{algorithmic} 
\end{algorithm}

The approximated solution, found by either SLM or KPM, will be denoted by $u^n$, where $n$ the same as the size for of the orthogonal space used ($n$). \\

If the solution is obtained without the use of an orthogonalisation, it will be denoted with DM for direct method.


\section{Zero initial condition}
For both KPM and SLM it is important that the initial conditions are zero. Equation \eqref{eqn:PDE} can be transformed so that it has zero initial conditions in the following way:
\begin{equation*}
\hat{u}(t) = u(t)-u_0
\end{equation*}
The original equation can then be written as
\begin{equation}
\begin{aligned}
\dot{\hat{u}}(t) &= A \hat{u}(t) +A u_0 + F(t) \\
 \hat{u}(0)&= 0 \\
 u(t) &= \hat{u} + u_0. \\
\end{aligned}
\end{equation}

All test problems with a non-zero initial condition will be transformed in this way.

\section{Discretization}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The number of points in each spacial direction is $m$, making the step size $h_s = 1/m$. The number of steps in time is $k$, making the step size $h_t = 1/k$.\\

Let the matrix $I_j$ be the identity matrix of size $j$, and let 
\begin{equation}
J_j = 
\begin{bmatrix}
0&I_j\\-I_j&0
\end{bmatrix}.
\end{equation}

Equation \eqref{eqn:PDE} can be the result of the discretization of several equation. Since SLM needs a Hamiltonian matrix this will be the main focus. One of the two implemented Hamiltonian matrices is the discretization of the 2 dimensional wave equation, 
\begin{equation}
\begin{aligned}
\frac{\partial^2 u}{\partial t^2} = \frac{\partial^2 u}{\partial x^2}+ \frac{\partial^2 u}{\partial y^2} + f(t,x,y).
\end{aligned}
\label{eqn:wave}
\end{equation}
This can be discretized to be on the form of equation \eqref{eqn:PDE}, with the matrix
\begin{equation}
\begin{aligned}
\tilde{A} &= \frac{2}{h_s^2} \text{ gallery}('\text{poisson}', m-2) \\
A &= 
\begin{bmatrix}
 0 & I_{\hat{m}} \\ - \tilde{A} & 0 \\
\end{bmatrix}
\end{aligned}.
\end{equation}
The matrix $\tilde{A}$ is also known as the five-point stencil\cite{fivepoint}. This matrix will be referred to as \texttt{wave} when used. The second implemented Hamiltonian matrix is random, and given by
\begin{equation}
\begin{aligned}
\hat{A} &= \text{rand}(\hat{m}) \\
A &= \frac{1}{2} J_{\hat{m}} (\hat{A} + \hat{A}^\top + m^2 I_{\hat{m}}).
\end{aligned}
\end{equation}
Since we are interested in comparing the different projection methods to each other, the matrix will be saved and reused when necessary. This matrix will be referred to as \texttt{semirandom}. The part $m^2 I_{\hat{m}} $ is added to make $J_{\hat{m}}A$ diagonally dominant, there would be no way of knowing if any of the methods would converge without this part.% The matrix is simulated to be a 2 dimensional system. 

These two matrices also has some test problems that satisfies the condition: $u(t,0,y) = u(t,1,y) = u(t,x,0) = u(t,x,1) = 0$. \\

In the case when the energy is constant and \texttt{wave} is used, the test problem is 
\begin{equation}
\begin{aligned}
u(t,x,y) &= \sin(\pi x) \sin(\pi y) \cos(\sqrt{2} \pi t) \\
u_0(x,y) &= \sin( \pi x) \sin(\pi y) \\
f(t,x,y) &= 0 ,
\end{aligned}
\end{equation}
and 
\begin{equation}
\begin{aligned}
u(t,x,y) &= \text{unknown} \\
u_0(x,y) &= \text{rand} (2 (m-2)^2,1) \\
f(t,x,y) &= 0
\end{aligned}
\end{equation}
for \texttt{semirandom}. This test problem is kept with the same conditions as $A$.

The source term $f(t,x,y)$ is chosen to be zero because it is easier to work with a constant energy. Some problems with non-constant energy will be presented later.\\

The test problems are discretized with $y_i = i h_s$, $x_i = i h_s$ and $t_j = j h_t$ with $i = 1,2,\cdots,m-1 $ and $ j = 1,2,\cdots,k $. The time discretized solution of $u$ will be called $U$.


\section{Lingo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%!!!!!!!!!!!!!!!!!!!!!Skriv noe her!!!!!!!!!!!!!!!!\\
!!!!!!!!!!!!!!!!!!!!!!!!Bedre navn på denne seksjonen!!!!!!!!!!!!!!!!\\
%!!!!!!!!!!!!!!!!!!!!!!!Forklare forskjellen på $u$ og $U$?!!!!!!!!!!!!!!!!\\
Table \ref{tab:labels} contains a short explanation of the labels you will see on figures later. 

%!!!!!!!!!!!!!!!!!!!!!Skriv noe her!!!!!!!!!!!!!!!!\\
%!!!!!!!!!!!!!!!!!!!!!!!Lag en bedre tabell!!!!!!!!!!!!!!!!\\

\begin{table}[h]
\centering
\begin{tabular}{l| l}
 iterations& number of restarts performed by Arnoldi or symplectic Lanczos method.  \\
 time & computation time elapsed when solving the problem \\
 error1 &  Difference in error between analytical solution, and estimated solution. \\
 energy1 & Difference between the largest and smallest energy during the simulated time. \\
 error2 & Difference in error between orthogonalised solution, and the\\& non-orthogonalised solution. \\
 energy2 &Difference in energy between orthogonalised solution, and the\\& non-orthogonalised solution. \\
$m$ & number of point in each spacial direction \\
$n$ & size of orthogonal space, also called restart variable \\
$k$ & number of points in time \\
$t$ & simulated time \\
\texttt{restart}& a boolean value. If \texttt{restart} == 1, Arnoldi or \\&symplectic Lanczos method will restart. \\
$\epsilon$ & if \texttt{restart} is true, restarting will\\& commence until the change in the solution\\& is less than $\epsilon$ \\
\end{tabular}
\caption{ Explanation of some labels. }
\label{tab:labels}
\end{table}

%!!!!!!!!!!!!!!!!!!!Fyll inn etterhvert som du trenger det!!!!!!!!!!!!!!!!!!!!\\