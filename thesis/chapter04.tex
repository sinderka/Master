%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Results for test problems with constant energy}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:constres}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This chapter will show how error, energy and computation time changes with $i_r$, $\iota$, $T_s$, $m$ and $n$. There are special interest in seeing how the energy for \texttt{SLM} behaves, how \texttt{KPM} and \texttt{SLM} differs, and how occurring problems might be handled. The predictions and proofs made in the theory chapter will also be tested. \\

\noindent For all sections except the first assume that $m=20$, and $k = 20$ per second. 
\section{Convergence}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This section will show convergence with the wave equation with all the integration methods presented in table \ref{tab:intmet} and \ref{tab:intcorrect}. The reason for only using the wave equation is that the analytical solution is unknown for \texttt{semirandom}. $T_s = 1$ second for all plots in this section.
\subsection{Numerical integration}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.30\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/intconv11r.jpg}
                \caption{ Convergence of trapezoidal rule without restart. }
                \label{fig:intconv11r}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.30\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/intconv12r.jpg}
                \caption{ Convergence of forward Euler without restart. }
                \label{fig:intconv12r}
        \end{subfigure}
        \begin{subfigure}[b]{0.30\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/intconv13r.jpg}
                \caption{ Convergence of midpoint rule without restart. }
                \label{fig:intconv13r}
        \end{subfigure}         
        
        \begin{subfigure}[b]{0.30\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/intconv11.jpg}
                \caption{ Convergence of trapezoidal rule with restart. }
                \label{fig:intconv11}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.30\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/intconv12.jpg}
                \caption{ Convergence of forward Euler with restart. }
                \label{fig:intconv12}
        \end{subfigure}
        \begin{subfigure}[b]{0.30\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/intconv13.jpg}
                \caption{ Convergence of midpoint rule with restart. }
                \label{fig:intconv13}
        \end{subfigure}
        
 
\caption{ Convergence for the different integration methods. Notice that forward Euler uses $k^2$ points in time where the other methods uses $k$ points in time to obtain the same accuracy. $n=2$ is kept constant for all plots, since smaller $n$ generally gives poorer convergence. For the figures with restart enabled $\iota = 1e-10$. 1 second is simulated. }
\label{fig:intconv}
\end{figure}
\noindent All methods converge with the expected rate. \\

\noindent Forward Euler has a worse run time than the other methods, due to the larger $k$ needed for the same convergence. It also has a tendency to diverge on longer time intervals and is in general not suited for the job. Figure \ref{fig:forwardenergy} shows the difference in energy between forward Euler(\ref{fig:fe1}) and trapezoidal rule (\ref{fig:fe2}). This difference in energy is reason enough not to use forward Euler any more.\\

\noindent Trapezoidal rule and midpoint rule converges quadratically and near identically, as they should. Since midpoint rule is symplectic, it will be used when restart is enabled. Trapezoidal rule has a faster run time, and will be used when restart is not enabled due to insignificant differences in error.%, since midpoint rule and trapezoidal rule is the same in this case.

\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/intener11.jpg}
                \caption{ Energy for trapezoidal rule. }
                \label{fig:fe1}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/intener12.jpg}
                \caption{ Energy for forward Euler. }  
				\label{fig:fe2}
        \end{subfigure}                
\caption{ A figure showing the difference in energy between trapezoidal rule and forward Euler when 1 second is simulated. }
\label{fig:forwardenergy}
\end{figure}

\subsection{Exact solvers} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:exactconv}
\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/exactconvtraperr.jpg}
                \caption{ Convergence of the exact solver using \texttt{diag} without restart. }
                \label{fig:exactconvtraperr}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/exactconvmiderr.jpg}
                \caption{ Convergence of the exact solver using \texttt{expm} without restart. }  
				\label{fig:exactconvmiderr}
        \end{subfigure}         
       
\caption{Convergence for exact solvers, with trapezoidal rule. Note that the exactness of the methods are for the integration in time, and not the spacial discretization. The expected convergence is therefore still quadratic with $m$. $n = 2$ because taking the matrix exponential is a costly operation and it is harder for the methods to converge when $n$ is small. 1 second is simulated. } %When restart is enabled $\iota = 1e-10$.
\label{fig:intexactt}
\end{figure}
The convergence is quadratic and identical for both integration methods. It might seem strange to include two different exact solvers which look so similar, but an important difference between the two explored in section \ref{sec:resultexpm}.

\section{Convergence of the restart}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This section will show how error and energy changes with $\iota$ and $i_r$.
\subsection{Convergence as a function of $\iota$}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/lcompareError.jpg}
                \caption{ Error for \texttt{wave}. }
                \label{fig:lcompareError}
        \end{subfigure}
		~
		\begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/lcompareErrorw.jpg}
                \caption{ Error for \texttt{semirandom}. }
                \label{fig:lcompareErrorw}
        \end{subfigure}
        
                \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/lcompareEnergy.jpg}
                \caption{ Energy for \texttt{wave}. }
                \label{fig:lcompareEnergy}
        \end{subfigure}
		~
		\begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/lcompareEnergyw.jpg}
                \caption{ Energy for \texttt{semirandom}. }
                \label{fig:lcompareEnergyw}
        \end{subfigure}
        
                \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/lcompareIter.jpg}
                \caption{ Number of restarts for \texttt{wave}. }
                \label{fig:lcompareIter}
        \end{subfigure}
		~
		\begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/lcompareIterw.jpg}
                \caption{ Number of restarts for \texttt{semirandom}. }
                \label{fig:lcompareIterw}
        \end{subfigure}
        \caption{ These figures show how choosing different $\iota$ affects the solution. The pictures on the left are for \texttt{wave} and on the right are for \texttt{semirandom}. This plot considers 100 seconds, with $k = 2000$, $n = m = 20$ and midpoint rule. \hfill $\neptune$  }
        \label{fig:lcompare}
\end{figure}
Figure \ref{fig:lcompare} shows that if \texttt{wave} is used there is no reason to use the restart. From figure \ref{fig:intconv} it seams to also be the case for larger $m$. This will therefore be the end of the discussion about \texttt{wave} in this chapter. If you are only interested in using a projection method on the wave equation with constant energy this is definitely a smart thing. The largest orthogonal space needed is about $n=2$ (depending on $T_s$), which gives an incredible run time.\\
The rest of this chapter will only consider \texttt{semirandom} since this is a more interesting case. \\

\noindent The number of restarts are the same for \texttt{KPM} and \texttt{SLM}. Another ting to notice is that there is little reason to restart after gaining a certain precision, since the changes will not be visible. $\iota$ should be chosen a few orders smaller than the accuracy of \texttt{DM}. Based on the pictures $\iota = 1e-6$ is suitable. \\

\noindent Some interesting results from \ref{fig:lcompareEnergyw} and \ref{fig:lcompareErrorw} is that both \texttt{KPM} and \texttt{SLM} needs to restart to gain a low error, but the energy for \texttt{SLM} increases the first times it restarts, before it starts sinking again. This shows that the energy can be accurately estimated by \texttt{SLM} without restart, but not (necessarily) the error.  Thus it is clear that \texttt{SLM} looses its energy preserving property when it restarts. If only the energy is of interest, the restart is not necessary. For \texttt{KPM} it is much simpler, more restart means better approximations, for both error and energy.\\

\section{Convergence with $i_r$} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/cierr2.jpg}
                \caption{ Error. }
                \label{fig:cierr2}
        \end{subfigure}
        ~
		\begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/ciene2.jpg}
                \caption{ Energy. }
                \label{fig:ciene2}
        \end{subfigure}    

        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/cierr1.jpg}
                \caption{ Error. }
                \label{fig:cierr1}
        \end{subfigure}
        ~
		\begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/ciene1.jpg}
                \caption{ Energy. }
                \label{fig:ciene1}
        \end{subfigure}
        \caption{ The top figures shows how the error and energy changes as a function of $i_r$. $T_s = 10$ is chosen to better show the decrease. The bottom pictures show how error and energy behaves with increasing time domain, with constant $i_r = 20$. }
        \label{fig:ci}
\end{figure}
Figure \ref{fig:ci} shows that a few restarts are needed before a better approximation is made. For \texttt{KPM}(6) and \texttt{SLM}(6) it is necessary to perform more than 5 restarts to gain any accuracy. After a certain number of restarts the change in the solution is too small to observe.  \\
The increase in error is linear for \ref{fig:cierr1}, which is what is predicted for these methods. \\
The increase in energy is sublinear. It was predicted that it would be constant for \texttt{SLM}. Why the increase happens will be examined later in this chapter.

\section{How to choose $n$}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:resultat}
This section will look at how to choose $n$ to avoid unnecessary restart and still obtain satisfactory results. Last section show that error and energy behaved quite similarly. Thus this section will only show error, since this is the most important property of the restart. We assume that all cases tested here are independent.

\subsection{Without restart} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/nerrorwA.jpg}
                \caption{ Error for \texttt{KPM}. }
                \label{fig:nerrorw}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/nerrorwA.jpg}
                \caption{ Energy for \texttt{SLM}. \\ }
                \label{fig:nenergyw}
        \end{subfigure}
        \caption{ The pictures shows which $n$ gives convergence for different $m$ when restart is not enabled. This plot is made with trapezoidal rule with $k = 200$ over 10 seconds. }
        \label{fig:n}
\end{figure}
Figure \ref{fig:n} shows that $n$ can be choose independent of $m$, as long as $n \geq 100$ and restart is not enabled.

\subsection{With restart} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/reserrA.jpg}
                \caption{ Error for \texttt{KPM}. }
                \label{fig:reserrS}
        \end{subfigure}
		~
		\begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/reserrS.jpg}
                \caption{ Error for \texttt{SLM}. }
                \label{fig:reseneA}
        \end{subfigure}
        \caption{ The pictures shows which $n$ gives convergence for different $m$ when restart is enabled. This plot is made with midpoint rule and $k = 200$ over 10 seconds. }
        \label{fig:res}

\end{figure}
Figure \ref{fig:res} shows that if restart is enabled, a good approximation of the solution can be found with $n \geq 20$, for any $m$.\\
The reason for the independence between $m$ and $n$ is probably due to the structure of the matrix, and is not a rule for the general Hamiltonian matrix.

\subsection{For time domains} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/terrorwA.jpg}
                \caption{ Error for \texttt{KPM} without restart. }
                \label{fig:terrorwA}
        \end{subfigure}
		~
		\begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/terrorwS.jpg}
                \caption{ Error for \texttt{SLM} without restart. }
                \label{fig:terrorwS}
        \end{subfigure}
        
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/terrorwAr.jpg}
                \caption{ Error for \texttt{KPM} with restart. }
                \label{fig:terrorwAr}
        \end{subfigure}
		~
		\begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/terrorwSr.jpg}
                \caption{ Error for \texttt{SLM} with restart. }
                \label{fig:terrorwSr}
        \end{subfigure}        
        
        \caption{ The pictures shows which $n$ gives convergence for different $T_s$, with $k = 20 \cdot T_s$ and $m = 20$. The top plots are without restart, and the bottom are with restart.}
        \label{fig:rest}
\end{figure}
Figure \ref{fig:rest} shows that the length of the time domain is affecting the choice of $n$. It seams that if $T_s$ is doubled, then $n$ needs to be doubled. Though this rule seams to be less important when restart is enabled. \\
\texttt{SLM} and \texttt{KPM} behaves very similarly in all pictures shown in this section. \\

\section{ Energy and error }%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:resultconsterergy}
The convergence section shows that increasing $m$ and $k$ will decrease the error of the solution. This has been done for short time (1 s). Convergence for the restart has been shown both for different $\iota$ and $i_r$. There has also been a discussion about how to chose $n$. The values of these will be kept at $n = 200$ when restart is not used. $n = 20$ and $\iota = 1e-6$ when restart is used. Remember that $m = 20$ except where stated. \\This section will look at how error and energy change as a function of time, and how the restarting and windowing interacts with this.


\subsection{Without restart} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/longtime2err.jpg}
                \caption{ Error. }
                \label{fig:longtime2err}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/longtime2ene.jpg}
                \caption{ Energy. }
                \label{fig:longtime8err}
        \end{subfigure}
        \caption{ The figures show how error and energy changes with larger time domains. $n = 200$, $m = 20$, and trapezoidal rule is used. }
        \label{fig:SLMenergyerror0}
\end{figure}
The energy and error for all methods increase, but slower than linear, and might be explained by small rounding errors that cannot be avoided when dealing with such small numbers. This is supported by the fact that the energy for \texttt{DM} increases equally fast as for the other methods. \\
The suddenly increase in error at the last point in figure \ref{fig:longtime2err} shows the instability of the projection methods, this also happens when restart is enabled, and will be explained further in section \ref{sec:longtime}. If the time domain was a little larger the projection methods would diverge. \\
Picture \ref{fig:longtime8err} shows that \texttt{SLM} preserves the energy, while \texttt{KPM} does not.

\subsection{With restart} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/longtime2rerr.jpg}
                \caption{ Error. }
                \label{fig:longtime2rerr}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/longtime2rene.jpg}
                \caption{ Energy. }
                \label{fig:longtime8rerr}
        \end{subfigure}
     
        
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/longtime2rite.jpg}
                \caption{ Number of restarts. }
                \label{fig:longtime2rene}
        \end{subfigure}
        \caption{ The figures show how error and energy changes with larger time domains when restart is enabled with $\iota = 1e-6$. $n = 20$, $m = 20$, and midpoint rule is used. }
        \label{fig:SLMenergyerror1}
\end{figure}
Figure \ref{fig:SLMenergyerror1} and \ref{fig:SLMenergyerror0} are quite similar, except for the last points. In this case the restarts can help with the convergence. If the last points are disregarded these methods are quite similar. Which method is most desirable will not become apparent before computation time is discussed. \\
The number of restarts increases linearly after the time domain has become sufficiently large. Larger time domains might therefor give a larger growth in computation time than expected. \\
\subsection{Windowing} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/Kversuskerror0.jpg}
                \caption{ Error without restart. }
                \label{fig:Kversuskerror0}
        \end{subfigure}
		~
		\begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/Kversuskenergy0.jpg}
                \caption{ Energy without restart. }
                \label{fig:Kversuskenergy0}
        \end{subfigure}

        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/Kversuskerror.jpg}
                \caption{ Error with restart. }
                \label{fig:Kversuskerror}
        \end{subfigure}
		~
		\begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/Kversuskenergy.jpg}
                \caption{ Energy with restart. }
                \label{fig:Kversuskenergy}
        \end{subfigure}        
        
        \caption{ The figures shows how windowing with and without restart changes the error and energy over time. $m = 20$, $k= 20$ and $\iota = 1-6$ when restart is enabled. }
        \label{fig:Kversusk}
\end{figure}
The divergence problems with the last points seams to be gone. Restarting makes the error a few orders smaller, but the growth is linear with $T_s$ for both cases. Since it is interesting to see the difference between \texttt{SLM} and \texttt{KPM}, restarting will not be used with windowing.
Both error and energy with windowing is comparable to the other cases. This makes windowing an interesting idea.
\subsection{Very long time} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In this section it is shown what will happen when the time domain becomes to large for the methods to converge.
\label{sec:longtime}
\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/vlongerr.jpg}
                \caption{ Error without restart. }
                \label{fig:vlongerr}
        \end{subfigure}
		~
		\begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/vlongene.jpg}
                \caption{ Energy without restart. }
                \label{fig:vlongene}
        \end{subfigure}
        
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/vlongerrr.jpg}
                \caption{ Error with restart. }
                \label{fig:vlongerrr}
        \end{subfigure}
		~
		\begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/vlongener.jpg}
                \caption{ Energy without restart. }
                \label{fig:vlongener}
        \end{subfigure}
        
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/vlongerrrK.jpg}
                \caption{ Error for windowing without restart. }
                \label{fig:vlongerrrK}
        \end{subfigure}
		~
		\begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/vlongenerK.jpg}
                \caption{ Energy with windowing without restart. }
                \label{fig:vlongenerK}
        \end{subfigure}        
        
        \caption{ This figure shows how different methods cope with a very long time domain. Windowing does not use restart.  }
        \label{fig:vlong}
\end{figure}
\noindent This figure shows something very interesting, namely that with restart or not, the error will diverge on long time domains if $n$ is kept constant. For \texttt{SLM} without restart the energy is always preserved (no matter what $n$, $m$, $T_s$ and $k$ is used), in all other cases \texttt{KPM} and \texttt{SLM} perform equally bad. There is an important difference between restarting and not. If restart is not enabled, the method will at one point not work, and the error will just be noise. But the numeric value of the approximated solution will be close to the numeric value of \texttt{DM}. With restart on the other hand, everything blows up exponentially. When windowing is used the problem can be worked around. In this case the trend of increasing energy and error continues as it did for 100 seconds. \\

\subsection{Energy in the transformations}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This section will show how the energy changes when transforming from $z_n(t)$ to $u_n(t)$.

\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/energswA.jpg}
                \caption{ Energy for \texttt{KPM}(200). }
                \label{fig:energyswA}
        \end{subfigure}
        ~
		\begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/energswS.jpg}
                \caption{ Energy for \texttt{SLM}(200). }
                \label{fig:energswS}
        \end{subfigure}        
        \caption{ The figures shows how the transformation between $z(t)$ and $u(t)$ changes the energy. Restart is not enabled, $m = 20$, and trapezoidal rule is used. }
        \label{fig:energs}
\end{figure}
\noindent For \texttt{KPM} there is a huge discrepancy between the energy of $z_{n}(t)$ and $u_{n}(t)$. For \texttt{SLM} there is no difference between the two. This shows the energy preserving properties of \texttt{SLM}. It is worth mentioning that $S_n J_{\hat{m}}S_n - J_n \sim 1e-16$ and $V_n^\top V_n - I_n \sim 1e-11$.
\subsection{Residual energy}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:residualenergy}
\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/SLMpes.jpg}
        \end{subfigure}
		
        \caption{ A plot of $\mathcal{H}_3$ and $\mathcal{H}_4$ for different time domains. }
        \label{fig:SLMpes}
\end{figure}
$\mathcal{H}_3$ and $\mathcal{H}_4$ are very similar, as is predicted in the theory section. The difference between the two is machine accuracy until $T_s$ gets to big (around 10 seconds). \\
\section{A different idea} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This section will see how using an exact solver can improve error and energy, compared to trapezoidal rule.\\
Unfortunately the test problems has some severe limitations. \texttt{wave} does not require a restart to be well approximated, and the analytical solution is unknown for \texttt{semirandom}. \\
If \texttt{semirandom} is used there will be no way of knowing if \texttt{DM} or the projection method gives the best approximation.
If \texttt{wave} is used the question about whether to use restart or not with exact solvers will remain unanswered. \\
Since the latter limitation is smaller
\texttt{wave} will be used. Restart will not be used since it is already known that the method will not restart.

\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/ideaerr20.jpg}
                \caption{ Error. }
                \label{fig:ideaerr20}
        \end{subfigure}%
        ~
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/ideaener20.jpg}
                \caption{ Energy. }
                \label{fig:ideaener20}
        \end{subfigure}
        \caption{ A figure showing how the error and energy changes when an exact solver (\texttt{diag}) is used. $n = 20$, $m = 20$, restart is not enabled. \texttt{DM} uses trapezoidal rule. }
        \label{fig:idea0}
\end{figure}
\noindent The error for the projection methods with an exact solver is smaller than the error for \texttt{DM} with trapezoidal rule. \\
The energy for \texttt{SLM} with \texttt{diag} increases linearly, why this happens is unknown, but a reasonable explanation is rounding errors. For both \texttt{KPM} and \texttt{DM} the energy is constant. It seams that \texttt{KPM} is better than \texttt{SLM} on long time domains in this setting. \\
The pictures also show that all errors are increasing linearly. \\
%Windowing is not necessary, since the exact solvers does not rely on iterating.

\subsection{Matlabs \texttt{expm} function} \label{sec:resultexpm} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This section will explain the reason for using \texttt{diag} instead of \texttt{expm}. %In section \ref{sec:exactconv} it is shown that the exact solver gives the same error.
\begin{figure}[H]
        \centering
		\begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/expmAerr.jpg}
                \caption{ Error. }
                \label{fig:expmSerr}
        \end{subfigure}%
        ~
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/expmAener.jpg}
                \caption{ Energy. }
                \label{fig:expmSener}
        \end{subfigure}
        \caption{A figure showing the difference in error and energy for the different exact integration methods. Restart is not enabled, $m = 20$. }
        \label{fig:expm}
\end{figure}
\noindent The error for the two exact solver are equal, but there is a big difference between in energy. \texttt{diag} has a constant energy for \texttt{KPM}, while with \texttt{expm} the increases is linear.\\
It seams that the energy preserving property of \texttt{SLM} is lost when using it with an exact solver, because of its linear increase, but \texttt{diag} has a better initial approximation than \texttt{expm}. \\
\section{Computation time}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:cruntime}
This section will compare computation time for the different methods discussed. 

\subsection{Without restart}

\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/timem.jpg}
                \caption{ Computation time as a function of $m$. }
                \label{fig:timem}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/timek.jpg}
                \caption{ Computation time as a function of $k$. }
                \label{fig:timek}
        \end{subfigure}
        \caption{ A figure of the computation times without restart. $n = 200$, $T_s = 100$, $k = 2000$, $m = 20$ unless stated. }
        \label{fig:time0}
\end{figure}
\noindent All computation times scales linearly with $k$, but \texttt{SLM} and \texttt{KPM} require much less computation time than \texttt{DM}. \\
The scaling with $m$ is a little more difficult, but \texttt{DM} seams to be increasing quadratically, while \texttt{SLM} and \texttt{KPM} increases closer to linear. Though the last points of the projection methods are suggesting a faster increase. \texttt{SLM} and \texttt{KPM} has very similar computation times.
\subsection{With restart}
Since $n$ can be chosen freely above a certain threshold, but smaller $n$ might give higher $i_r$, it is interesting to see how computation time changes as a function of $n$. When restart is not enabled it is quite obvious that smaller $n$ gives smaller computation times.\\
\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/timemr.jpg}
                \caption{ Computation time as a function of $m$. }
                \label{fig:timemr}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/timekr.jpg}
                \caption{ Computation time as a function of $k$. }
                \label{fig:timekr}
        \end{subfigure}
        
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/timekr1.jpg}
                \caption{ Computation time as a function of $n$. }
                \label{fig:timekr1}
        \end{subfigure}        
        
        \caption{ The top pictures show the computation times with restart. The bottom picture shows how computation time changes as a function of $n$. $n = 20$, $T_s = 100$, $k = 2000$, and $m = 20$ unless stated. }
        \label{fig:time1}
\end{figure}

\noindent \texttt{SLM} and \texttt{DM} is now increasing equally fast with $m$, while \texttt{KPM} increases about the same as without restart. In this case \texttt{DM} would be a better choice than \texttt{SLM}, while \texttt{KPM} at least gives a smaller computation time. \\
Computation time as a function of $k$ increases faster for \texttt{KPM} than for the other methods. This is because \texttt{KPM} needs more restarts on larger time domains, and makes \texttt{KPM} useful when $m$ is large and $k$ is small. For \texttt{SLM} this effect is not visible. \\
Figure \ref{fig:timekr1} shows that computation times are depending on $n$. For \texttt{KPM} this effect is very important. \\

\subsection{Windowing}
\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/timemt.jpg}
                \caption{ Computation time as a function of $m$. }
                \label{fig:timemt}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/timekt.jpg}
                \caption{ Computation time as a function of $k$. }
                \label{fig:timekt}
        \end{subfigure}
        \caption{ A figure of the computation times with restart. $n = 20$, $T_s = 100$, $k = 20$ per second, and $m = 20$ unless stated. }
        \label{fig:time2}
\end{figure}
Windowing gives the best performance for \texttt{SLM} and \texttt{KPM} till now. It is interesting that this method gives the best estimates for error and error, and the fastest computation time. The reason for the faster computation time is probably the small $n$ without the need to restart. 
\subsection{With \texttt{diag}}
\begin{figure}[H]
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/timeme.jpg}
                \caption{ Computation time as a function of $m$. }
                \label{fig:timeme}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{../MATLAB/fig/timeke.jpg}
                \caption{ Computation time as a function of $k$. }
                \label{fig:timeke}
        \end{subfigure}
        \caption{ A figure of the computation times with \texttt{diag}. $n = 20$, $T_s = 100$, $k = 2000$, $m = 20$ unless stated. }
        \label{fig:time3}
\end{figure}
Figure \ref{fig:time3} shows that the exact solver without restart is even faster than windowing. This might be due to a artificially small $n$, due to the unconditional convergence with \texttt{wave}.
